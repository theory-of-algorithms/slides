%!TEX root = slides.tex

\section{Computational complexity}


\begin{frame}{Languages}
  \begin{description}
    \item[Alphabet] Finite set of symbols, denoted $\Sigma$.
    \item[Word] Sequence of symbols, $w$ from $\Sigma$.
    \item[Language] Set of words, denoted $L$.
    \item[Length] Of a word, denoted $|w|$  .
    \item[Empty word] Unique word of length 0, denoted $\lambda$.
  \end{description}
\end{frame}


\begin{frame}{Kleene star}
  \begin{description}
    \item[Words] $w_1 w_2$ is the concatenation of words $w_1$ and $w_2$.
    \item[Languages] $L_1 L_2$ is the language resulting from the concatenation of all words in $L_1$ and all words in $L_2$, in that order.
    \item[Powers] $L^0 = \{ \lambda \}$, $L^1 = L$ and $L^{n+1} = L^n L$ for all $n > 1$.
  \end{description}
  
  \vspace{0.5cm}
  
  \begin{block}{Kleene Star}
     \[ L^* =  \bigcup_{i=0}^{\infty} L^i \]
  \end{block}
  
  Note that treating the alphabet $\Sigma$ as a language in itself, we get that $\Sigma^*$ is the set of all words over $\Sigma$.
\end{frame}


\begin{frame}{Example}
  \begin{description}
    \item[$\Sigma$] $\{ 0, 1 \}$
    \item[$L$] $\{ 00, 01, 10, 11 \}$
    \item[$w_1$] $01$
    \item[$w_3$] $11$
    \item[$w_1 w_3$] $0111$
    \item[$\Sigma^*$] $\{ \lambda, 0, 1, 00, 01, 10, 11, 001, 010, \ldots \}$
    \item[$L^*$] $\{ \lambda, 00, 01, 10, 11, 0000, 0001, \ldots \}$
    \item[$L^+$] $\{ 00, 01, 10, 11, 0000, 0001, \ldots \}$
  \end{description}
\end{frame}


\begin{frame}[fragile]{Exponential}
  \begin{exampleblock}{How many numbers can we represent with $k$ bits?}
    \begin{itemize}
      \item Consider the case of four bits.
      \item Imagine four placeholders:  \textbf{\fbox{?}}\textbf{\fbox{?}}\textbf{\fbox{?}}\textbf{\fbox{?}}
      \item Each placeholder can contain either 0 or 1.
      \item There are $2 \times 2 \times 2 \times 2 = 2^4 = 16$ different numbers.
      \item Add another bit, how many numbers is it now?
      \item It's $2 \times 2 \times 2 \times 2 \times 2 = 2^5 = 32$.
      \item Generally $k$ bits can represent $2^k$ numbers.
      \item This grows \textbf{exponentially} relative to $k$.
    \end{itemize}
  \end{exampleblock}
\end{frame}


\begin{frame}{Polynomial time}
  \begin{definition}
  An algorithm is said to be solvable in \emph{polynomial time} if the number of steps required to complete the algorithm for a given input is $O(n^k)$ for some nonnegative integer $k$, where $n$ is the complexity of the input.
  \end{definition}
  
  \vspace{0.5cm}
  \metroset{block=fill}
  \begin{block}{$P$ complexity class}
  The $P$ complexity class is the set of problems for which there exists, for each such problem, at least one algorithm to solve that problem in polynomial time.
  \end{block}

  \citeurl{mathworld.wolfram.com/P-Problem.html}
\end{frame}


\begin{frame}{Non-deterministic polynomial time}
  \begin{definition}
  A problem is in the $NP$ complexity class if it is solvable by a non-deterministic Turing Machine in polynomial time. A non-deterministic Turing Machine is one which may not have a unique action to take for some or all states and inputs.
  \end{definition}
  
  \vspace{0.5cm}
  \metroset{block=fill}
  \begin{block}{$P$ is a subset of $NP$}
  The $P$ complexity class is a subset of $P$ because all polynomial time solvabled problems can be modelled using Nondeterministic Turing Machinses.
  \end{block}

  \citeurl{mathworld.wolfram.com/P-Problem.html}
\end{frame}


\begin{frame}{Decision problems}
  \begin{description}
    \item[Decision problems] are problems where the answer is 0 or 1.
    \vspace{0.5cm}
    \item[Restricting] ourselves to decision problems is convenient and fair.
    \vspace{0.5cm}
    \item[$f:\{0,1\}^n \rightarrow \{0,1\}$] is useful notation for considering decision problems.
    \vspace{0.5cm}
    \item[Other problems] can be easily (polynomial time) adapted into decision problems.
  \end{description}
\end{frame}
